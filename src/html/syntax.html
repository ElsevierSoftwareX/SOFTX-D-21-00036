<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB 2020b"><title>DynaProg</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.8px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: 400; text-align: left;  }
.S1 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.S2 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.S3 { border-left: 0px none rgb(0, 0, 0); border-right: 0px none rgb(0, 0, 0); border-top: 0px none rgb(0, 0, 0); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 0px; line-height: 16px; min-height: 16px; white-space: pre; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 12px;  }
.S4 { margin: 10px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 15px; font-weight: 700; text-align: left;  }
.S5 { margin: 10px 0px 20px; padding-left: 0px; font-family: Helvetica, Arial, sans-serif; font-size: 14px;  }
.S6 { margin-left: 56px; line-height: 21px; min-height: 0px; text-align: left; white-space: pre-wrap;  }
.S7 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: 700; text-align: left;  }</style></head><body><div class = rtcContent><h1  class = 'S0' id = 'T_305D4575' ><span>DynaProg</span></h1><div  class = 'S1'><span>Solve multi-stage deterministic decision problems</span></div><h2  class = 'S2' id = 'H_F09D08F5' ><span>Syntax</span></h2><div class = 'preformatted-matlab' style = 'margin: 10px 3px 10px 55px; padding: 10px 10px 10px 5px; '><div  class = 'S3'><span style="white-space: pre;"><span>prob = DynaProg(StateGrid, StateInitial, StateFinal, ControlGrid, NStages, SysName)</span></span></div><div  class = 'S3'><span style="white-space: pre;"><span>prob = DynaProg(StateGrid, StateInitial, [], ControlGrid, NStages, SysName)</span></span></div><div  class = 'S3'><span style="white-space: pre;"><span>prob = DynaProg(StateGrid, StateInitial, StateFinal, ControlGrid, NStages, ExtSysName, IntSysName)</span></span></div><div  class = 'S3'><span style="white-space: pre;"><span>prob = DynaProg(</span><span style="color: rgb(255, 0, 0);">__</span><span>, Name, Value)</span></span></div><div  class = 'S3'></div><div  class = 'S3'><span style="white-space: pre;"><span>prob = run(prob)</span></span></div><div  class = 'S3'><span style="white-space: pre;"><span>plot(prob)</span></span></div></div><h2  class = 'S2' id = 'H_31B35881' ><span>Description</span></h2><div  class = 'S1'><a href = "#H_9FE2499E"><span style=' font-family: monospace;'>prob</span></a><span style=' font-family: monospace;'> = DynaProg(</span><a href = "#H_E1616ABE"><span style=' font-family: monospace;'>StateGrid</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_B28539B7"><span style=' font-family: monospace;'>StateInitial</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_A944F2B8"><span style=' font-family: monospace;'>StateFinal</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_4CD65B8C"><span style=' font-family: monospace;'>ControlGrid</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_DDBB8435"><span style=' font-family: monospace;'>NStages</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_ED3B20E2"><span style=' font-family: monospace;'>SysName</span></a><span style=' font-family: monospace;'>) </span><span>creates the basic problem structure </span><span style=' font-family: monospace;'>prob</span><span>.</span></div><div  class = 'S1'><a href = "#H_9FE2499E"><span style=' font-family: monospace;'>prob</span></a><span style=' font-family: monospace;'> = DynaProg(</span><a href = "#H_E1616ABE"><span style=' font-family: monospace;'>StateGrid</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_B28539B7"><span style=' font-family: monospace;'>StateInitial</span></a><span style=' font-family: monospace;'>, [], </span><a href = "#H_4CD65B8C"><span style=' font-family: monospace;'>ControlGrid</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_DDBB8435"><span style=' font-family: monospace;'>NStages</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_ED3B20E2"><span style=' font-family: monospace;'>SysName</span></a><span style=' font-family: monospace;'>)</span><span>  creates the basic problem structure </span><span style=' font-family: monospace;'>prob</span><span>, with no contraints on the final state.</span></div><div  class = 'S1'><a href = "#H_9FE2499E"><span style=' font-family: monospace;'>prob</span></a><span style=' font-family: monospace;'> = DynaProg(</span><a href = "#H_E1616ABE"><span style=' font-family: monospace;'>StateGrid</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_B28539B7"><span style=' font-family: monospace;'>StateInitial</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_A944F2B8"><span style=' font-family: monospace;'>StateFinal</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_4CD65B8C"><span style=' font-family: monospace;'>ControlGrid</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_DDBB8435"><span style=' font-family: monospace;'>NStages</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_88B8643C"><span style=' font-family: monospace;'>ExtSysName</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_038C78B9"><span style=' font-family: monospace;'>IntSysName</span></a><span style=' font-family: monospace;'>)</span><span> creates the basic problem structure prob, using the configuration matrices approach.</span></div><div  class = 'S1'><a href = "#H_9FE2499E"><span style=' font-family: monospace;'>prob</span></a><span style=' font-family: monospace;'> = DynaProg(__, </span><a href = "#H_2F2B9A2D"><span style=' font-family: monospace;'>Name</span></a><span style=' font-family: monospace;'>, </span><a href = "#H_2F2B9A2D"><span style=' font-family: monospace;'>Value</span></a><span style=' font-family: monospace;'>) </span><span>specifies additional properties and information with parameter/value pairs.</span></div><div  class = 'S1'><a href = "#H_9FE2499E"><span style=' font-family: monospace;'>prob</span></a><span style=' font-family: monospace;'> = run(prob) </span><span>runs the optimization algorithm on an existing problem structure and stores the results in the problem structure </span><span style=' font-family: monospace;'>prob</span><span>.</span></div><div  class = 'S1'><span style=' font-family: monospace;'>plot(prob) </span><span>visualizes results of an existing problem structure containing optimization results.</span></div><h2  class = 'S2' id = 'H_7F17859C' ><span>Input Arguments</span></h2><h4  class = 'S4' id = 'H_E1616ABE' ><span style=' font-family: monospace;'>StateGrid</span></h4><div  class = 'S1'><span style=' font-family: monospace;'>StateGrid</span><span> is a cell array of numeric vectors, where each vector defines the discretized grid for a state variable.</span></div><h4  class = 'S4' id = 'H_B28539B7' ><span style=' font-family: monospace;'>StateInitial</span></h4><div  class = 'S1'><span style=' font-family: monospace;'>StateInitial</span><span> is a cell array of scalar values, where each value defines the initial value for a state variable.</span></div><h4  class = 'S4' id = 'H_A944F2B8' ><span style=' font-family: monospace;'>StateFinal</span></h4><div  class = 'S1'><span style=' font-family: monospace;'>StateFinal</span><span> is a cell array of two-element vectors, where each vector defines lower and upper constraints for the final value for each state variable. Each vector must contain the lower and upper bound, in this order.</span></div><h4  class = 'S4' id = 'H_4CD65B8C' ><span style=' font-family: monospace;'>ControlGrid</span></h4><div  class = 'S1'><span style=' font-family: monospace;'>ControlGrid </span><span>is a cell array of numeric vectors, where each vector defines the discretized grid for a control variable.    </span></div><h4  class = 'S4' id = 'H_DDBB8435' ><span style=' font-family: monospace;'>NStages</span><span>    </span></h4><div  class = 'S1'><span style=' font-family: monospace;'>NStages</span><span> is the number of stages of the optimization problem.</span></div><h4  class = 'S4' id = 'H_ED3B20E2' ><span style=' font-family: monospace;'>SysName</span></h4><div  class = 'S1'><span style=' font-family: monospace;'>SyaName</span><span> is a function handle to the model function. The model function must return the updated state value and the stage cost as a function of the current state value and the control variables. Additionally, it can accept an exogenous input and it can return unfeasibilities.The structure of the model function must be:</span></div><div  class = 'S1'><span>     </span><span style=' font-family: monospace;'>[x_next, stageCost, unfeas] = SysName(x, u, w);</span></div><div  class = 'S1'><span>where:</span></div><ul  class = 'S5'><li  class = 'S6'><span style=' font-family: monospace;'>x</span><span> is a cell array, where each cell contains the value for a state variable.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>u</span><span> is a cell array, where each cell contains the value for a control variable.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>w</span><span> (optional) is a cell array, where each cell contains the value for an exogenous input variable. If not needed, replace with a tilde (~) in the function signature.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>x_next </span><span>is a cell array, where each cell contains the value for the updated state variable.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>stageCost</span><span> is a numeric variable, containing the stage cost.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>unfeas </span><span>is either an empty array a boolean variable, set to true for unfeasible (not allowed) combinations of state variables, control variables and exogenous inputs. If not needed, return an empty array ([]) in its place.</span></li></ul><h4  class = 'S4' id = 'H_88B8643C' ><span style=' font-family: monospace;'>ExtSysName</span></h4><div  class = 'S1'><span style=' font-family: monospace;'>ExtSysName </span><span>is a function handle to the external model function. The external model function must return the intermediate variables as a function of the control variables. Additionally, it can accept exogenous inputs and it can return unfeasibilities. The structure of the external model function must be:    </span></div><div  class = 'S1'><span style=' font-family: monospace;'>    [m, unfeas] = ExtSysName(u, w);</span></div><div  class = 'S1'><span>where:</span></div><div  class = 'S1'><span style=' font-family: monospace;'>u</span><span> is a cell array, where each cell contains the value for a control variable. </span></div><div  class = 'S1'><span style=' font-family: monospace;'>w</span><span> (optional) is a cell array, where each cell contains the value for an exogenous input variable.</span></div><div  class = 'S1'><span style=' font-family: monospace;'>m</span><span> is a cell array, where each cell contains the value for an intermediate variable.</span></div><div  class = 'S1'><span style=' font-family: monospace;'>unfeas </span><span>(optional) is a boolean variable, set to true for unfeasible (not allowed) combinations of state variables, control variables and exogenous inputs.</span></div><h4  class = 'S4' id = 'H_038C78B9' ><span style=' font-family: monospace;'>IntSysName</span></h4><div  class = 'S1'><span style=' font-family: monospace;'>IntSysName </span><span>is a function handle to the internal model function. The internal model function must return the updated state value and the stage cost as a function of the current state value, the control variables and the intermediate variables. Additionally, it can accept an exogenous input and it can return unfeasibilities (both are optional).</span></div><div  class = 'S1'><span>The structure of the model function must be:</span></div><div  class = 'S1'><span style=' font-family: monospace;'>[x_next, stageCost, unfeas] = IntSysName(x, u, m, w);</span></div><div  class = 'S1'><span>where:</span></div><ul  class = 'S5'><li  class = 'S6'><span style=' font-family: monospace;'>x</span><span> is a cell array, where each cell contains the value for a state variable.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>u</span><span> is a cell array, where each cell contains the value for a control variable.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>m</span><span> is a cell array, where each cell contains the value for an intermediate variable.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>w</span><span> (optional) is a cell array, where each cell contains the value for an exogenous input variable.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>x_next</span><span> is a cell array, where each cell contains the value for the updated state variable.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>stageCost </span><span>is a numeric variable, containing the stage cost.</span></li><li  class = 'S6'><span style=' font-family: monospace;'>unfeas</span><span> (optional) is a boolean variable, set to true for unfeasible (not allowed) combinations of state variables, control variables and exogenous inputs.</span></li></ul><h3  class = 'S7' id = 'H_2F2B9A2D' ><span>Name-Value Pair Arguments</span></h3><div  class = 'S1'><span>Optional arguments. Specify each argument with a pair of arguments </span><span style=' font-family: monospace;'>Name, Value. Name </span><span>is one of the argument names specified below and it must be written inside quotes.  </span><span style=' font-family: monospace;'>Value </span><span>is the value you want to specify for that setting. You can specify any number of name-value pair arguments, in any order.</span></div><h4  class = 'S4' id = 'H_AA34F1F5' ><span style=' font-weight: bold; font-family: monospace;'>'UseLevelSet'</span></h4><div  class = 'S1'><span>Enable Level-Set DP. Defaults to false if unspecified.</span></div><h4  class = 'S4' id = 'H_C96247C3' ><span style=' font-weight: bold; font-family: monospace;'>'ExogenousInput'</span></h4><div  class = 'S1'><span>Specify exogenous inputs required for your model in a cell array of numeric vectors. Each vector must have the same length as the number of stages of the optimization problem.</span></div><h4  class = 'S4' id = 'H_46FC9527' ><span style=' font-family: monospace;'>'StateName'</span></h4><div  class = 'S1'><span>Specify state variables names in a string array. </span></div><h4  class = 'S4' id = 'H_AF88898F' ><span style=' font-family: monospace;'>'ControlName'</span></h4><div  class = 'S1'><span>Specify state variables names in a string array.</span></div><h4  class = 'S4' id = 'H_E4B2F10F' ><span style=' font-weight: bold; font-family: monospace;'>'CostName'</span></h4><div  class = 'S1'><span>Specify the cumulative cost name as a string.</span></div><h4  class = 'S4' id = 'H_340BB385' ><span style=' font-weight: bold; font-family: monospace;'>'Time'</span></h4><div  class = 'S1'><span>Specify time instead of stages. This property is only used in the plots produced with the plot method. It does not affect the optimization.</span></div><h2  class = 'S2'><span>Output Arguments</span></h2><h4  class = 'S4' id = 'H_9FE2499E' ><span style=' font-family: monospace;'>prob</span></h4><div  class = 'S1'><span>Problem structure, containing all the information required to set up and run the optimization. After </span><span style=' font-family: monospace;'>run</span><span> is used on a problem structure to run the optmization algorithm, it also contains the optimization results.</span></div></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% DynaProg
% Solve multi-stage deterministic decision problems
%% Syntax
%%
% 
%   prob = DynaProg(StateGrid, StateInitial, StateFinal, ControlGrid, NStages, SysName)
%   prob = DynaProg(StateGrid, StateInitial, [], ControlGrid, NStages, SysName)
%   prob = DynaProg(StateGrid, StateInitial, StateFinal, ControlGrid, NStages, ExtSysName, IntSysName)
%   prob = DynaProg(__, Name, Value)
%   
%   prob = run(prob)
%   plot(prob)
%
%% Description
% <internal:H_9FE2499E |prob|> |= DynaProg(|<internal:H_E1616ABE |StateGrid|>|,| 
% <internal:H_B28539B7 |StateInitial|>|,| <internal:H_A944F2B8 |StateFinal|>|,| 
% <internal:H_4CD65B8C |ControlGrid|>|,| <internal:H_DDBB8435 |NStages|>|,| <internal:H_ED3B20E2 
% |SysName|>|)| creates the basic problem structure |prob|.
% 
% <internal:H_9FE2499E |prob|> |= DynaProg(|<internal:H_E1616ABE |StateGrid|>|,| 
% <internal:H_B28539B7 |StateInitial|>|, [],| <internal:H_4CD65B8C |ControlGrid|>|,| 
% <internal:H_DDBB8435 |NStages|>|,| <internal:H_ED3B20E2 |SysName|>|)|  creates 
% the basic problem structure |prob|, with no contraints on the final state.
% 
% <internal:H_9FE2499E |prob|> |= DynaProg(|<internal:H_E1616ABE |StateGrid|>|,| 
% <internal:H_B28539B7 |StateInitial|>|,| <internal:H_A944F2B8 |StateFinal|>|,| 
% <internal:H_4CD65B8C |ControlGrid|>|,| <internal:H_DDBB8435 |NStages|>|,| <internal:H_88B8643C 
% |ExtSysName|>|,| <internal:H_038C78B9 |IntSysName|>|)| creates the basic problem 
% structure prob, using the configuration matrices approach.
% 
% <internal:H_9FE2499E |prob|> |= DynaProg(__,| <internal:H_2F2B9A2D |Name|>|,| 
% <internal:H_2F2B9A2D |Value|>|)| specifies additional properties and information 
% with parameter/value pairs.
% 
% <internal:H_9FE2499E |prob|> |= run(prob)| runs the optimization algorithm 
% on an existing problem structure and stores the results in the problem structure 
% |prob|.
% 
% |plot(prob)| visualizes results of an existing problem structure containing 
% optimization results.
%% Input Arguments
% |StateGrid|
% |StateGrid| is a cell array of numeric vectors, where each vector defines 
% the discretized grid for a state variable.
% |StateInitial|
% |StateInitial| is a cell array of scalar values, where each value defines 
% the initial value for a state variable.
% |StateFinal|
% |StateFinal| is a cell array of two-element vectors, where each vector defines 
% lower and upper constraints for the final value for each state variable. Each 
% vector must contain the lower and upper bound, in this order.
% |ControlGrid|
% |ControlGrid| is a cell array of numeric vectors, where each vector defines 
% the discretized grid for a control variable.    
% |NStages|    
% |NStages| is the number of stages of the optimization problem.
% |SysName|
% |SyaName| is a function handle to the model function. The model function must 
% return the updated state value and the stage cost as a function of the current 
% state value and the control variables. Additionally, it can accept an exogenous 
% input and it can return unfeasibilities.The structure of the model function 
% must be:
% 
% |[x_next, stageCost, unfeas] = SysName(x, u, w);|
% 
% where:
%% 
% * |x| is a cell array, where each cell contains the value for a state variable.
% * |u| is a cell array, where each cell contains the value for a control variable.
% * |w| (optional) is a cell array, where each cell contains the value for an 
% exogenous input variable. If not needed, replace with a tilde (~) in the function 
% signature.
% * |x_next| is a cell array, where each cell contains the value for the updated 
% state variable.
% * |stageCost| is a numeric variable, containing the stage cost.
% * |unfeas| is either an empty array a boolean variable, set to true for unfeasible 
% (not allowed) combinations of state variables, control variables and exogenous 
% inputs. If not needed, return an empty array ([]) in its place.
% |ExtSysName|
% |ExtSysName| is a function handle to the external model function. The external 
% model function must return the intermediate variables as a function of the control 
% variables. Additionally, it can accept exogenous inputs and it can return unfeasibilities. 
% The structure of the external model function must be:    
% 
% |[m, unfeas] = ExtSysName(u, w);|
% 
% where:
% 
% |u| is a cell array, where each cell contains the value for a control variable. 
% 
% |w| (optional) is a cell array, where each cell contains the value for an 
% exogenous input variable.
% 
% |m| is a cell array, where each cell contains the value for an intermediate 
% variable.
% 
% |unfeas| (optional) is a boolean variable, set to true for unfeasible (not 
% allowed) combinations of state variables, control variables and exogenous inputs.
% |IntSysName|
% |IntSysName| is a function handle to the internal model function. The internal 
% model function must return the updated state value and the stage cost as a function 
% of the current state value, the control variables and the intermediate variables. 
% Additionally, it can accept an exogenous input and it can return unfeasibilities 
% (both are optional).
% 
% The structure of the model function must be:
% 
% |[x_next, stageCost, unfeas] = IntSysName(x, u, m, w);|
% 
% where:
%% 
% * |x| is a cell array, where each cell contains the value for a state variable.
% * |u| is a cell array, where each cell contains the value for a control variable.
% * |m| is a cell array, where each cell contains the value for an intermediate 
% variable.
% * |w| (optional) is a cell array, where each cell contains the value for an 
% exogenous input variable.
% * |x_next| is a cell array, where each cell contains the value for the updated 
% state variable.
% * |stageCost| is a numeric variable, containing the stage cost.
% * |unfeas| (optional) is a boolean variable, set to true for unfeasible (not 
% allowed) combinations of state variables, control variables and exogenous inputs.
% Name-Value Pair Arguments
% Optional arguments. Specify each argument with a pair of arguments |Name, 
% Value. Name| is one of the argument names specified below and it must be written 
% inside quotes.  |Value| is the value you want to specify for that setting. You 
% can specify any number of name-value pair arguments, in any order.
% |*'UseLevelSet'*|
% Enable Level-Set DP. Defaults to false if unspecified.
% |*'ExogenousInput'*|
% Specify exogenous inputs required for your model in a cell array of numeric 
% vectors. Each vector must have the same length as the number of stages of the 
% optimization problem.
% |'StateName'|
% Specify state variables names in a string array. 
% |'ControlName'|
% Specify state variables names in a string array.
% |*'CostName'*|
% Specify the cumulative cost name as a string.
% |*'Time'*|
% Specify time instead of stages. This property is only used in the plots produced 
% with the plot method. It does not affect the optimization.
%% Output Arguments
% |prob|
% Problem structure, containing all the information required to set up and run 
% the optimization. After |run| is used on a problem structure to run the optmization 
% algorithm, it also contains the optimization results.
##### SOURCE END #####
--></body></html>